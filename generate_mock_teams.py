#!/usr/bin/env python3
"""
generate_mock_teams.py

Generates mock Teams and Venues tied 1:1 to those teams.
- U.S. city names from geonamescache (authentic list).
- Mascots are unique, color prefixes used probabilistically.
- Seed randomizes each run and is appended to output filenames by default.

Team CSV columns:
  team_id, team_code, team_school, team_mascot, team_email, team_website

Venue CSV columns:
  venue_id, venue_name, venue_street, venue_city, venue_state, venue_zip, venue_phone, venue_team_id

Install once:
  pip install geonamescache Faker
"""
import argparse
import csv
import os
import random
import re
import sys
# ---- deps ----
try:
    from geonamescache import GeonamesCache
except ImportError:
    print("Missing dependency: geonamescache. Install with: pip install geonamescache", file=sys.stderr)
    sys.exit(1)
try:
    from faker import Faker
except ImportError:
    print("Missing dependency: Faker. Install with: pip install Faker", file=sys.stderr)
    sys.exit(1)

# ---------------------------
# CONFIG (editable defaults)
# ---------------------------
NUM_TEAMS_DEFAULT = 10          # used if Enter is pressed at the prompt without input
START_ID_DEFAULT = 1001
VENUE_START_ID_DEFAULT = 3001
OUTPUT_FILE_DEFAULT = "mock_teams.csv"
VENUE_OUTPUT_FILE_DEFAULT = "mock_venues.csv"
COLOR_RATE_DEFAULT = 0.33      # probability a mascot gets a color prefix

# CLI Explanation Banner
RUN_MESSAGE = """\
This script generates mock teams and venues, and writes CSV output.

Columns (teams): team_id, team_code, team_school, team_mascot, team_email, team_website
Columns (venues): venue_id, venue_name, venue_street, venue_city, venue_state, venue_zip, venue_phone, venue_team_id

You can safely generate a list of more than 1,500 unique teams, mascots, & venues.
"""

# Curated mascot pool. Script will still ensure uniqueness.
# Pool below contains more than 100 silly mascots, meaning approximately 1,800 unique mascots can be generated by randomly combining mascots with color names.
MASCOT_POOL = [
    "Aardvarks","Alpacas","Amoebas","Anteaters","Armadillos","Artichokes","Bananas","Bearded Dragons","Beavers","Blobfish","Butterflies","Cactuses","Camels","Capybaras","Caterpillars","Chameleons","Chinchillas","Chipmunks","Chupacabras","Dandelions","Dolphins","Donkeys","Dung Beetles","Dust Bunnies","Elephants","Elves","Ferrets","Flamingos","Flying Squirrels","Frogs","Geckos","Giraffes","Gnomes","Goats","Goblins","Gophers","Guinea Pigs","Hamsters","Hedgehogs","Horseshoe Crabs","Hummingbirds","Jellyfish","Kangaroos","Koalas","Lemurs","Lizards","Llamas","Manatees","Mastodons","Meerkats","Monkeys","Mosquitoes","Moths","Mudskippers","Mules","Naked Mole Rats","Narwhals","Opossums","Orangutans","Ostriches","Otters","Owls","Pandas","Parrots","Parsnips","Peacocks","Pelicans","Penguins","Phantoms","Pigs","Pinecones","Platypuses","Polar Bears","Porcupines","Prairie Dogs","Praying Mantises","Puffer Fish","Rabbits","Raccoons","Radishes","Reindeers","Rutabagas","Sand Dollars","Sardines","Seals","Skunks","Sloths","Snails","Spatulas","Sporks","Squids","Squirrels","Sugar Gliders","Swans","Tapeworms","Toads","Toasters","Tortoises","Tree Frogs","Tumbleweeds","Turnips","Turtles","Velociraptors","Waffles","Wombats","Woodpeckers","Yaks","Zebras"
]

# Color pool for optional prefixes
COLOR_POOL = [
    "Black","White","Red","Blue","Green","Gold","Silver","Maroon","Purple","Orange",
    "Navy","Crimson","Scarlet","Teal","Brown","Gray","Rainbow"
]

MAX_MASCOT_COMBOS = len(MASCOT_POOL) * (len(COLOR_POOL) + 1)  # +1 for no-color

# ---------------------------
# US Cities via geonamescache
# ---------------------------
_gc = GeonamesCache()
_cities = _gc.get_cities()  # dict keyed by geonameid
_US_CITY_NAMES: list[str] = []
_seen: set[str] = set()
for c in _cities.values():
    if c.get("countrycode") == "US":
        name = c.get("name")
        if name and name not in _seen:
            _seen.add(name)
            _US_CITY_NAMES.append(name)
if not _US_CITY_NAMES:
    print("No U.S. cities found in geonamescache dataset. Check installation.", file=sys.stderr)
    sys.exit(1)

# ---------------------------
# Helpers
# ---------------------------
def slugify(s: str) -> str:
    s = s.strip().lower()
    s = re.sub(r'[^a-z0-9]+', '-', s)
    s = re.sub(r'-{2,}', '-', s)
    return s.strip('-')

def generate_unique_team_code(base_name: str, existing: set[str]) -> str:
    """
    4-char code derived from base_name. If collision, suffix numbers within 4 chars.
    """
    cleaned = re.sub(r'[^A-Za-z]', '', (base_name or '').upper())
    base = (cleaned or "EXT")[:4] or "EXT"
    if base not in existing:
        return base
    for i in range(1, 1000):
        candidate = f"{base[:3]}{i}"[:4]
        if candidate not in existing:
            return candidate
    n = 1
    while True:
        candidate = f"{base[:2]}{n:02d}"[:4]
        if candidate not in existing:
            return candidate
        n += 1

def choose_seed(user_seed: int | None) -> int:
    if user_seed is not None:
        return user_seed
    return int.from_bytes(os.urandom(8), "big", signed=False)

def build_seeded_output_path(path: str, seed: int, enabled: bool = True) -> str:
    if not enabled:
        return path
    base, ext = os.path.splitext(path)
    return f"{base}_seed{seed}{ext}" if ext else f"{base}_seed{seed}"

def prompt_int(prompt: str, default_val: int) -> int:
    try:
        s = input(f"{prompt}: ").strip()
        if not s:
            return default_val
        val = int(s)
        if val <= 0:
            raise ValueError
        return val
    except (EOFError, KeyboardInterrupt):
        print()
        sys.exit(1)
    except ValueError:
        print("Please enter a positive integer.")
        return prompt_int(prompt, default_val)

def pick_us_cities(count: int) -> list[str]:
    """
    Return 'count' distinct U.S. city names.
    Raises error if the requested number of teams exceeds available unique names.
    """
    available = len(_US_CITY_NAMES)
    if count > available:
        raise ValueError(
            f"Requested {count} unique cities but only {available} exist "
            "in the dataset without adding suffixes."
        )
    return random.sample(_US_CITY_NAMES, count)

def generate_unique_mascots(count: int, color_rate: float) -> list[str]:
    """
    Returns 'count' unique mascot strings.
    Uniqueness = (color or None, base).
    Raises if requested count exceeds available combinations.
    """
    if count > MAX_MASCOT_COMBOS:
        raise ValueError(
            f"Requested {count} teams but only {MAX_MASCOT_COMBOS} unique "
            f"mascot combinations are possible with current pools."
        )

    used: set[tuple[str | None, str]] = set()
    out: list[str] = []
    attempts = 0
    max_attempts = 10000

    while len(out) < count:
        base = random.choice(MASCOT_POOL)
        use_color = random.random() < color_rate
        color = random.choice(COLOR_POOL) if use_color else None
        key = (color, base)
        if key in used:
            attempts += 1
            if attempts > max_attempts:
                raise RuntimeError("Unable to generate unique mascots.")
            continue
        used.add(key)
        out.append(f"{color} {base}" if color else base)

    return out

def generate_teams(num_teams: int, start_id: int, color_rate: float) -> list[dict]:
    # Cities and mascots are unique lists, so pairs are inherently unique
    schools = pick_us_cities(num_teams)
    mascots = generate_unique_mascots(num_teams, color_rate)

    existing_codes: set[str] = set()
    records: list[dict] = []

    for idx in range(num_teams):
        team_id = start_id + idx
        team_school = schools[idx]
        team_mascot = mascots[idx]

        code = generate_unique_team_code(team_school, existing_codes)
        existing_codes.add(code)

        school_slug = slugify(team_school)
        mascot_slug = slugify(team_mascot)
        email = f"{mascot_slug}@{school_slug}.com"
        website = f"https://{school_slug}{mascot_slug}.com"

        records.append({
            "team_id": team_id,
            "team_code": code,
            "team_school": team_school,
            "team_mascot": team_mascot,
            "team_email": email,
            "team_website": website,
        })
    return records

def generate_venues_for_teams(teams: list[dict], venue_start_id: int) -> list[dict]:
    fake = Faker("en_US")
    venues: list[dict] = []
    for i, team in enumerate(teams):
        vid = venue_start_id + i
        city = team["team_school"]
        venues.append({
            "venue_id": vid,
            "venue_name": f"{city} High School",
            "venue_street": fake.street_address(),
            "venue_city": city,
            "venue_state": fake.state_abbr(),
            "venue_zip": fake.zipcode(),
            "venue_phone": fake.phone_number(),
            "venue_team_id": team["team_id"],
        })
    return venues

def write_csv(records: list[dict], path: str, fieldnames: list[str]) -> None:
    with open(path, "w", newline="") as f:
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()
        writer.writerows(records)

def parse_args(argv: list[str] | None = None) -> argparse.Namespace:
    p = argparse.ArgumentParser(description="Generate mock teams CSV.")
    p.add_argument("--num-teams", type=int, default=None, help="Number of teams to generate (prompts if omitted)")
    p.add_argument("--start-id", type=int, default=START_ID_DEFAULT, help="Starting team_id (sequential)")
    p.add_argument("--venue-start-id", type=int, default=VENUE_START_ID_DEFAULT, help="Starting venue_id (sequential)")
    p.add_argument("--out", default=OUTPUT_FILE_DEFAULT, help="Teams output CSV path")
    p.add_argument("--venue-out", default=VENUE_OUTPUT_FILE_DEFAULT, help="Venues output CSV path")
    p.add_argument("--seed", type=int, default=None, help="Optional fixed random seed for reproducibility")
    p.add_argument("--color-rate", type=float, default=COLOR_RATE_DEFAULT, help="Probability a mascot gets a color prefix (0..1)")
    p.add_argument("--no-seed-suffix", action="store_true", help="Do not append the seed to the output filename(s)")
    return p.parse_args(argv)

def main(argv: list[str] | None = None) -> int:
    args = parse_args(argv)

    # Show banner message before prompts
    if RUN_MESSAGE.strip():
        print(RUN_MESSAGE.strip())

    # How many teams?
    num_teams = args.num_teams
    if num_teams is None and sys.stdin.isatty():
        num_teams = prompt_int("How many teams should be generated?", NUM_TEAMS_DEFAULT)
    elif num_teams is None:
        num_teams = NUM_TEAMS_DEFAULT

    # Seed and generation
    seed = choose_seed(args.seed)
    random.seed(seed)

    teams = generate_teams(num_teams, args.start_id, args.color_rate)
    venues = generate_venues_for_teams(teams, args.venue_start_id)

    # Seed-suffixed output paths
    teams_out = build_seeded_output_path(args.out, seed, enabled=(not args.no_seed_suffix))
    venue_out = build_seeded_output_path(args.venue_out, seed, enabled=(not args.no_seed_suffix))

    # Write separate files
    print(f"Generating {num_teams} teams -> {teams_out}")
    print(f"Generating {num_teams} venues -> {venue_out}")

    team_fields = ["team_id","team_code","team_school","team_mascot","team_email","team_website"]
    venue_fields = ["venue_id","venue_name","venue_street","venue_city","venue_state","venue_zip","venue_phone","venue_team_id"]

    write_csv(teams, teams_out, team_fields)
    write_csv(venues, venue_out, venue_fields)

    print(f"Wrote {len(teams)} teams to {teams_out}")
    print(f"Wrote {len(venues)} venues to {venue_out}")
    return 0

if __name__ == "__main__":
    raise SystemExit(main())
